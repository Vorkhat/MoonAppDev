// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               v5.27.1
// source: tracker.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from '@bufbuild/protobuf/wire';
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from '@grpc/grpc-js';
import { Empty } from './google/protobuf/empty';

export const protobufPackage = 'tracker';

export interface SubscribedChannel {
    channelId: number;
    name: string;
}

export interface GetChannelsResponse {
    channels: SubscribedChannel[];
}

export interface SubscribeChannelRequest {
    joinHash?: string | undefined;
    username?: string | undefined;
}

function createBaseSubscribedChannel(): SubscribedChannel {
    return { channelId: 0, name: '' };
}

export const SubscribedChannel: MessageFns<SubscribedChannel> = {
    encode(message: SubscribedChannel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.channelId !== 0) {
            writer.uint32(8).int64(message.channelId);
        }
        if (message.name !== '') {
            writer.uint32(18).string(message.name);
        }
        return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): SubscribedChannel {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubscribedChannel();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }

                    message.channelId = longToNumber(reader.int64());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }

                    message.name = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },

    create<I extends Exact<DeepPartial<SubscribedChannel>, I>>(base?: I): SubscribedChannel {
        return SubscribedChannel.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<SubscribedChannel>, I>>(object: I): SubscribedChannel {
        const message = createBaseSubscribedChannel();
        message.channelId = object.channelId ?? 0;
        message.name = object.name ?? '';
        return message;
    },
};

function createBaseGetChannelsResponse(): GetChannelsResponse {
    return { channels: [] };
}

export const GetChannelsResponse: MessageFns<GetChannelsResponse> = {
    encode(message: GetChannelsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        for (const v of message.channels) {
            SubscribedChannel.encode(v!, writer.uint32(10).fork()).join();
        }
        return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): GetChannelsResponse {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetChannelsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }

                    message.channels.push(SubscribedChannel.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },

    create<I extends Exact<DeepPartial<GetChannelsResponse>, I>>(base?: I): GetChannelsResponse {
        return GetChannelsResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<GetChannelsResponse>, I>>(object: I): GetChannelsResponse {
        const message = createBaseGetChannelsResponse();
        message.channels = object.channels?.map((e) => SubscribedChannel.fromPartial(e)) || [];
        return message;
    },
};

function createBaseSubscribeChannelRequest(): SubscribeChannelRequest {
    return { joinHash: undefined, username: undefined };
}

export const SubscribeChannelRequest: MessageFns<SubscribeChannelRequest> = {
    encode(message: SubscribeChannelRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.joinHash !== undefined) {
            writer.uint32(10).string(message.joinHash);
        }
        if (message.username !== undefined) {
            writer.uint32(18).string(message.username);
        }
        return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): SubscribeChannelRequest {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubscribeChannelRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }

                    message.joinHash = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }

                    message.username = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },

    create<I extends Exact<DeepPartial<SubscribeChannelRequest>, I>>(base?: I): SubscribeChannelRequest {
        return SubscribeChannelRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<SubscribeChannelRequest>, I>>(object: I): SubscribeChannelRequest {
        const message = createBaseSubscribeChannelRequest();
        message.joinHash = object.joinHash ?? undefined;
        message.username = object.username ?? undefined;
        return message;
    },
};

export type TrackerService = typeof TrackerService;
export const TrackerService = {
    getChannels: {
        path: '/tracker.Tracker/GetChannels',
        requestStream: false,
        responseStream: false,
        requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
        requestDeserialize: (value: Buffer) => Empty.decode(value),
        responseSerialize: (value: GetChannelsResponse) => Buffer.from(GetChannelsResponse.encode(value).finish()),
        responseDeserialize: (value: Buffer) => GetChannelsResponse.decode(value),
    },
    subscribeChannel: {
        path: '/tracker.Tracker/SubscribeChannel',
        requestStream: false,
        responseStream: false,
        requestSerialize: (value: SubscribeChannelRequest) => Buffer.from(
            SubscribeChannelRequest.encode(value).finish()),
        requestDeserialize: (value: Buffer) => SubscribeChannelRequest.decode(value),
        responseSerialize: (value: SubscribedChannel) => Buffer.from(SubscribedChannel.encode(value).finish()),
        responseDeserialize: (value: Buffer) => SubscribedChannel.decode(value),
    },
} as const;

export interface TrackerServer extends UntypedServiceImplementation {
    getChannels: handleUnaryCall<Empty, GetChannelsResponse>;
    subscribeChannel: handleUnaryCall<SubscribeChannelRequest, SubscribedChannel>;
}

export interface TrackerClient extends Client {
    getChannels(
        request: Empty,
        callback: (error: ServiceError | null, response: GetChannelsResponse) => void,
    ): ClientUnaryCall;

    getChannels(
        request: Empty,
        metadata: Metadata,
        callback: (error: ServiceError | null, response: GetChannelsResponse) => void,
    ): ClientUnaryCall;

    getChannels(
        request: Empty,
        metadata: Metadata,
        options: Partial<CallOptions>,
        callback: (error: ServiceError | null, response: GetChannelsResponse) => void,
    ): ClientUnaryCall;

    subscribeChannel(
        request: SubscribeChannelRequest,
        callback: (error: ServiceError | null, response: SubscribedChannel) => void,
    ): ClientUnaryCall;

    subscribeChannel(
        request: SubscribeChannelRequest,
        metadata: Metadata,
        callback: (error: ServiceError | null, response: SubscribedChannel) => void,
    ): ClientUnaryCall;

    subscribeChannel(
        request: SubscribeChannelRequest,
        metadata: Metadata,
        options: Partial<CallOptions>,
        callback: (error: ServiceError | null, response: SubscribedChannel) => void,
    ): ClientUnaryCall;
}

export const TrackerClient = makeGenericClientConstructor(TrackerService, 'tracker.Tracker') as unknown as {
    new(address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): TrackerClient;
    service: typeof TrackerService;
    serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
                                               : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
                                                                                     : T extends ReadonlyArray<infer U>
                                                                                       ? ReadonlyArray<DeepPartial<U>>
                                                                                       : T extends {}
                                                                                         ? { [K in keyof T]?: DeepPartial<T[K]> }
                                                                                         : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
                                                      : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
    const num = globalThis.Number(int64.toString());
    if (num > globalThis.Number.MAX_SAFE_INTEGER) {
        throw new globalThis.Error('Value is larger than Number.MAX_SAFE_INTEGER');
    }
    if (num < globalThis.Number.MIN_SAFE_INTEGER) {
        throw new globalThis.Error('Value is smaller than Number.MIN_SAFE_INTEGER');
    }
    return num;
}

export interface MessageFns<T> {
    encode(message: T, writer?: BinaryWriter): BinaryWriter;

    decode(input: BinaryReader | Uint8Array, length?: number): T;

    create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;

    fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
